//! The `string` type and its trait implementations.
//!
//! Strings in Ray are length-prefixed byte sequences stored as a raw pointer
//! and a length. They are not null-terminated. Strings support equality
//! comparison, hashing (for use as `dict` keys), and concatenation via `+`.

/// A UTF-8 string represented as a pointer to bytes and a length.
struct string {
    raw_ptr: rawptr[u8]
    len: uint
}

/// Strings convert to themselves (identity conversion).
impl ToStr[string] {
    fn to_str(self) => self
}

/// Byte-by-byte equality comparison for strings.
///
/// Two strings are equal if they have the same length and identical bytes.
impl Eq[string, string] {
    fn ==(a: string, b: string) -> bool {
        if a.len != b.len {
            return false
        }

        mut i: uint = 0
        while i < a.len {
            pa = a.raw_ptr + i
            pb = b.raw_ptr + i
            if *pa != *pb {
                return false
            }
            i += 1
        }

        true
    }
}

/// FNV-1a hashing for strings, hashing each byte sequentially.
impl Hash[string] {
    fn hash(self: string) -> u64 {
        // FNV-1a (64-bit)
        mut h: u64 = 14695981039346656037u64
        mut i: uint = 0
        while i < self.len {
            b = *(self.raw_ptr + i)
            h = h ^ (b as u64)
            h = h * 1099511628211u64
            i += 1
        }
        h
    }
}

/// String concatenation. Returns a new string containing `a` followed by `b`.
impl Add[string, string, string] {
    fn +(a: string, b: string) -> string {
        len = a.len + b.len
        raw_ptr = malloc(len)

        mut src_len = a.len
        mut src_ptr = a.raw_ptr
        mut dst_ptr = raw_ptr
        memcopy(dst_ptr, src_ptr, src_len)
        dst_ptr = dst_ptr + src_len

        src_len = b.len
        src_ptr = b.raw_ptr
        memcopy(dst_ptr, src_ptr, src_len)

        string { raw_ptr, len }
    }
}
