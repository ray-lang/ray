//! Operator traits and implementations for all numeric types.
//!
//! This module defines the traits that power Ray's operator syntax. When you
//! write `a + b`, the compiler resolves it to a call to `Add::+(a, b)`. Each
//! operator has a corresponding trait, and types opt into operators by providing
//! implementations.
//!
//! # Arithmetic Operators
//!
//! | Syntax | Trait  | Description          |
//! |--------|--------|----------------------|
//! | `a + b` | `Add` | Addition             |
//! | `a - b` | `Sub` | Subtraction          |
//! | `a * b` | `Mul` | Multiplication       |
//! | `a / b` | `Div` | Division             |
//! | `a % b` | `Mod` | Remainder / modulo   |
//! | `-a`    | `Neg` | Negation (prefix)    |
//!
//! # Comparison Operators
//!
//! | Syntax   | Trait  | Description              |
//! |----------|--------|--------------------------|
//! | `a == b` | `Eq`   | Equality                 |
//! | `a != b` | `Neq`  | Inequality               |
//! | `a > b`  | `Gt`   | Greater than             |
//! | `a < b`  | `Lt`   | Less than                |
//! | `a >= b` | `GtEq` | Greater than or equal    |
//! | `a <= b` | `LtEq` | Less than or equal       |
//!
//! # Logical Operators
//!
//! | Syntax    | Trait | Description   |
//! |-----------|-------|---------------|
//! | `a && b`  | `And` | Logical AND   |
//! | `a \|\| b` | `Or`  | Logical OR    |
//! | `!a`      | `Not` | Logical NOT   |
//!
//! # Bitwise Operators
//!
//! | Syntax  | Trait    | Description       |
//! |---------|---------|-------------------|
//! | `a & b` | `BitAnd` | Bitwise AND       |
//! | `a \| b` | `BitOr`  | Bitwise OR        |
//! | `a ^ b` | `BitXor` | Bitwise XOR       |
//!
//! All arithmetic, comparison, and bitwise operators are implemented for every
//! integer type: `int`, `i8`, `i16`, `i32`, `i64`, `uint`, `u8`, `u16`, `u32`, `u64`.
//! Negation (`Neg`) is only implemented for signed types.

import intrinsics with *

// ---------------------------------------------------------------------------
// Arithmetic operators
// ---------------------------------------------------------------------------

/// Addition operator (`+`).
///
/// # Type Parameters
///
/// - `'a` — Left operand type.
/// - `'b` — Right operand type.
/// - `'c` — Result type.
///
/// All built-in numeric implementations use the same type for all three
/// parameters (e.g., `Add[int, int, int]`). The three-parameter design
/// allows user-defined types to support heterogeneous addition, such as
/// adding a scalar to a vector.
///
/// # Examples
///
/// ```ray
/// result = 1 + 2       // 3
/// total = price + tax   // works for any type implementing Add
/// ```
trait Add['a, 'b, 'c] {
    /// Returns the sum of `a` and `b`.
    fn +(a: 'a, b: 'b) -> 'c
}

impl Add[int, int, int] {
    @inline
    fn +(a: int, b: int) -> int => int_add(a, b)
}

impl Add[i8, i8, i8] {
    @inline
    fn +(a: i8, b: i8) -> i8 => i8_add(a, b)
}

impl Add[i16, i16, i16] {
    @inline
    fn +(a: i16, b: i16) -> i16 => i16_add(a, b)
}

impl Add[i32, i32, i32] {
    @inline
    fn +(a: i32, b: i32) -> i32 => i32_add(a, b)
}

impl Add[i64, i64, i64] {
    @inline
    fn +(a: i64, b: i64) -> i64 => i64_add(a, b)
}

impl Add[uint, uint, uint] {
    @inline
    fn +(a: uint, b: uint) -> uint => uint_add(a, b)
}

impl Add[u8, u8, u8] {
    @inline
    fn +(a: u8, b: u8) -> u8 => u8_add(a, b)
}

impl Add[u16, u16, u16] {
    @inline
    fn +(a: u16, b: u16) -> u16 => u16_add(a, b)
}

impl Add[u32, u32, u32] {
    @inline
    fn +(a: u32, b: u32) -> u32 => u32_add(a, b)
}

impl Add[u64, u64, u64] {
    @inline
    fn +(a: u64, b: u64) -> u64 => u64_add(a, b)
}

/// Subtraction operator (`-`).
///
/// # Type Parameters
///
/// - `'a` — Left operand type.
/// - `'b` — Right operand type.
/// - `'c` — Result type.
trait Sub['a, 'b, 'c] {
    /// Returns the difference of `a` and `b`.
    fn -(a: 'a, b: 'b) -> 'c
}

impl Sub[int, int, int] {
    @inline
    fn -(a: int, b: int) -> int => int_sub(a, b)
}

impl Sub[i8, i8, i8] {
    @inline
    fn -(a: i8, b: i8) -> i8 => i8_sub(a, b)
}

impl Sub[i16, i16, i16] {
    @inline
    fn -(a: i16, b: i16) -> i16 => i16_sub(a, b)
}

impl Sub[i32, i32, i32] {
    @inline
    fn -(a: i32, b: i32) -> i32 => i32_sub(a, b)
}

impl Sub[i64, i64, i64] {
    @inline
    fn -(a: i64, b: i64) -> i64 => i64_sub(a, b)
}

impl Sub[uint, uint, uint] {
    @inline
    fn -(a: uint, b: uint) -> uint => uint_sub(a, b)
}

impl Sub[u8, u8, u8] {
    @inline
    fn -(a: u8, b: u8) -> u8 => u8_sub(a, b)
}

impl Sub[u16, u16, u16] {
    @inline
    fn -(a: u16, b: u16) -> u16 => u16_sub(a, b)
}

impl Sub[u32, u32, u32] {
    @inline
    fn -(a: u32, b: u32) -> u32 => u32_sub(a, b)
}

impl Sub[u64, u64, u64] {
    @inline
    fn -(a: u64, b: u64) -> u64 => u64_sub(a, b)
}

/// Multiplication operator (`*`).
///
/// # Type Parameters
///
/// - `'a` — Left operand type.
/// - `'b` — Right operand type.
/// - `'c` — Result type.
trait Mul['a, 'b, 'c] {
    /// Returns the product of `a` and `b`.
    fn *(a: 'a, b: 'b) -> 'c
}

impl Mul[int, int, int] {
    @inline
    fn *(a: int, b: int) -> int => int_mul(a, b)
}

impl Mul[i8, i8, i8] {
    @inline
    fn *(a: i8, b: i8) -> i8 => i8_mul(a, b)
}

impl Mul[i16, i16, i16] {
    @inline
    fn *(a: i16, b: i16) -> i16 => i16_mul(a, b)
}

impl Mul[i32, i32, i32] {
    @inline
    fn *(a: i32, b: i32) -> i32 => i32_mul(a, b)
}

impl Mul[i64, i64, i64] {
    @inline
    fn *(a: i64, b: i64) -> i64 => i64_mul(a, b)
}

impl Mul[uint, uint, uint] {
    @inline
    fn *(a: uint, b: uint) -> uint => uint_mul(a, b)
}

impl Mul[u8, u8, u8] {
    @inline
    fn *(a: u8, b: u8) -> u8 => u8_mul(a, b)
}

impl Mul[u16, u16, u16] {
    @inline
    fn *(a: u16, b: u16) -> u16 => u16_mul(a, b)
}

impl Mul[u32, u32, u32] {
    @inline
    fn *(a: u32, b: u32) -> u32 => u32_mul(a, b)
}

impl Mul[u64, u64, u64] {
    @inline
    fn *(a: u64, b: u64) -> u64 => u64_mul(a, b)
}

/// Division operator (`/`).
///
/// Performs integer division (truncated toward zero) for integer types.
///
/// # Type Parameters
///
/// - `'a` — Dividend type.
/// - `'b` — Divisor type.
/// - `'c` — Quotient type.
///
/// # Panics
///
/// Division by zero is undefined behavior on WASM and will trap at runtime.
trait Div['a, 'b, 'c] {
    /// Returns the quotient of `a` divided by `b`.
    fn /(a: 'a, b: 'b) -> 'c
}

impl Div[int, int, int] {
    @inline
    fn /(a: int, b: int) -> int => int_div(a, b)
}

impl Div[i8, i8, i8] {
    @inline
    fn /(a: i8, b: i8) -> i8 => i8_div(a, b)
}

impl Div[i16, i16, i16] {
    @inline
    fn /(a: i16, b: i16) -> i16 => i16_div(a, b)
}

impl Div[i32, i32, i32] {
    @inline
    fn /(a: i32, b: i32) -> i32 => i32_div(a, b)
}

impl Div[i64, i64, i64] {
    @inline
    fn /(a: i64, b: i64) -> i64 => i64_div(a, b)
}

impl Div[uint, uint, uint] {
    @inline
    fn /(a: uint, b: uint) -> uint => uint_div(a, b)
}

impl Div[u8, u8, u8] {
    @inline
    fn /(a: u8, b: u8) -> u8 => u8_div(a, b)
}

impl Div[u16, u16, u16] {
    @inline
    fn /(a: u16, b: u16) -> u16 => u16_div(a, b)
}

impl Div[u32, u32, u32] {
    @inline
    fn /(a: u32, b: u32) -> u32 => u32_div(a, b)
}

impl Div[u64, u64, u64] {
    @inline
    fn /(a: u64, b: u64) -> u64 => u64_div(a, b)
}

/// Remainder / modulo operator (`%`).
///
/// Returns the remainder after integer division. The result has the same
/// sign as the dividend for signed types.
///
/// # Type Parameters
///
/// - `'a` — Dividend type.
/// - `'b` — Divisor type.
/// - `'c` — Remainder type.
trait Mod['a, 'b, 'c] {
    /// Returns the remainder of `a` divided by `b`.
    fn %(a: 'a, b: 'b) -> 'c
}

impl Mod[int, int, int] {
    @inline
    fn %(a: int, b: int) -> int => int_mod(a, b)
}

impl Mod[i8, i8, i8] {
    @inline
    fn %(a: i8, b: i8) -> i8 => i8_mod(a, b)
}

impl Mod[i16, i16, i16] {
    @inline
    fn %(a: i16, b: i16) -> i16 => i16_mod(a, b)
}

impl Mod[i32, i32, i32] {
    @inline
    fn %(a: i32, b: i32) -> i32 => i32_mod(a, b)
}

impl Mod[i64, i64, i64] {
    @inline
    fn %(a: i64, b: i64) -> i64 => i64_mod(a, b)
}

impl Mod[uint, uint, uint] {
    @inline
    fn %(a: uint, b: uint) -> uint => uint_mod(a, b)
}

impl Mod[u8, u8, u8] {
    @inline
    fn %(a: u8, b: u8) -> u8 => u8_mod(a, b)
}

impl Mod[u16, u16, u16] {
    @inline
    fn %(a: u16, b: u16) -> u16 => u16_mod(a, b)
}

impl Mod[u32, u32, u32] {
    @inline
    fn %(a: u32, b: u32) -> u32 => u32_mod(a, b)
}

impl Mod[u64, u64, u64] {
    @inline
    fn %(a: u64, b: u64) -> u64 => u64_mod(a, b)
}

/// Arithmetic negation operator (prefix `-`).
///
/// Only implemented for signed integer types (`int`, `i8`, `i16`, `i32`, `i64`).
/// Unsigned integers cannot be negated.
///
/// # Type Parameters
///
/// - `'a` — The operand type.
/// - `'b` — The result type (same as `'a` for built-in types).
///
/// # Examples
///
/// ```ray
/// x = 42
/// y = -x   // -42
/// ```
trait Neg['a, 'b] {
    /// Returns the arithmetic negation of `a`.
    fn -(a: 'a) -> 'b
}

impl Neg[int, int] {
    @inline
    fn -(a: int) -> int => int_neg(a)
}

impl Neg[i8, i8] {
    @inline
    fn -(a: i8) -> i8 => i8_neg(a)
}

impl Neg[i16, i16] {
    @inline
    fn -(a: i16) -> i16 => i16_neg(a)
}

impl Neg[i32, i32] {
    @inline
    fn -(a: i32) -> i32 => i32_neg(a)
}

impl Neg[i64, i64] {
    @inline
    fn -(a: i64) -> i64 => i64_neg(a)
}

// ---------------------------------------------------------------------------
// Logical operators
// ---------------------------------------------------------------------------

/// Logical AND operator (`&&`).
///
/// Short-circuit evaluation: if `a` is `false`, `b` is not evaluated.
///
/// # Examples
///
/// ```ray
/// if is_valid && is_ready {
///     proceed()
/// }
/// ```
trait And['a, 'b] {
    /// Returns `true` if both `a` and `b` are `true`.
    fn &&(a: 'a, b: 'b) -> bool
}

impl And[bool, bool] {
    fn &&(a: bool, b: bool) -> bool => bool_and(a, b)
}

/// Logical OR operator (`||`).
///
/// Short-circuit evaluation: if `a` is `true`, `b` is not evaluated.
///
/// # Examples
///
/// ```ray
/// if is_admin || is_owner {
///     allow_access()
/// }
/// ```
trait Or['a, 'b] {
    /// Returns `true` if either `a` or `b` is `true`.
    fn ||(a: 'a, b: 'b) -> bool
}

impl Or[bool, bool] {
    fn ||(a: bool, b: bool) -> bool => bool_or(a, b)
}

/// Logical NOT operator (`!`).
///
/// # Examples
///
/// ```ray
/// if !is_done {
///     keep_working()
/// }
/// ```
trait Not['a] {
    /// Returns the logical negation of `a`.
    fn !(a: 'a) -> bool
}

impl Not[bool] {
    fn !(a: bool) -> bool => bool_not(a)
}

// ---------------------------------------------------------------------------
// Bitwise operators
// ---------------------------------------------------------------------------

/// Bitwise AND operator (`&`).
///
/// Performs a bitwise AND on each pair of corresponding bits. A result
/// bit is `1` only if both input bits are `1`.
///
/// # Type Parameters
///
/// - `'a` — Left operand type.
/// - `'b` — Right operand type.
/// - `'c` — Result type.
trait BitAnd['a, 'b, 'c] {
    /// Returns the bitwise AND of `a` and `b`.
    fn &(a: 'a, b: 'b) -> 'c
}

impl BitAnd[int, int, int] {
    @inline
    fn &(a: int, b: int) -> int => int_bit_and(a, b)
}

impl BitAnd[i8, i8, i8] {
    @inline
    fn &(a: i8, b: i8) -> i8 => i8_bit_and(a, b)
}

impl BitAnd[i16, i16, i16] {
    @inline
    fn &(a: i16, b: i16) -> i16 => i16_bit_and(a, b)
}

impl BitAnd[i32, i32, i32] {
    @inline
    fn &(a: i32, b: i32) -> i32 => i32_bit_and(a, b)
}

impl BitAnd[i64, i64, i64] {
    @inline
    fn &(a: i64, b: i64) -> i64 => i64_bit_and(a, b)
}

impl BitAnd[uint, uint, uint] {
    @inline
    fn &(a: uint, b: uint) -> uint => uint_bit_and(a, b)
}

impl BitAnd[u8, u8, u8] {
    @inline
    fn &(a: u8, b: u8) -> u8 => u8_bit_and(a, b)
}

impl BitAnd[u16, u16, u16] {
    @inline
    fn &(a: u16, b: u16) -> u16 => u16_bit_and(a, b)
}

impl BitAnd[u32, u32, u32] {
    @inline
    fn &(a: u32, b: u32) -> u32 => u32_bit_and(a, b)
}

impl BitAnd[u64, u64, u64] {
    @inline
    fn &(a: u64, b: u64) -> u64 => u64_bit_and(a, b)
}

/// Bitwise OR operator (`|`).
///
/// Performs a bitwise OR on each pair of corresponding bits. A result
/// bit is `1` if either input bit is `1`.
///
/// # Type Parameters
///
/// - `'a` — Left operand type.
/// - `'b` — Right operand type.
/// - `'c` — Result type.
trait BitOr['a, 'b, 'c] {
    /// Returns the bitwise OR of `a` and `b`.
    fn |(a: 'a, b: 'b) -> 'c
}

impl BitOr[int, int, int] {
    @inline
    fn |(a: int, b: int) -> int => int_bit_or(a, b)
}

impl BitOr[i8, i8, i8] {
    @inline
    fn |(a: i8, b: i8) -> i8 => i8_bit_or(a, b)
}

impl BitOr[i16, i16, i16] {
    @inline
    fn |(a: i16, b: i16) -> i16 => i16_bit_or(a, b)
}

impl BitOr[i32, i32, i32] {
    @inline
    fn |(a: i32, b: i32) -> i32 => i32_bit_or(a, b)
}

impl BitOr[i64, i64, i64] {
    @inline
    fn |(a: i64, b: i64) -> i64 => i64_bit_or(a, b)
}

impl BitOr[uint, uint, uint] {
    @inline
    fn |(a: uint, b: uint) -> uint => uint_bit_or(a, b)
}

impl BitOr[u8, u8, u8] {
    @inline
    fn |(a: u8, b: u8) -> u8 => u8_bit_or(a, b)
}

impl BitOr[u16, u16, u16] {
    @inline
    fn |(a: u16, b: u16) -> u16 => u16_bit_or(a, b)
}

impl BitOr[u32, u32, u32] {
    @inline
    fn |(a: u32, b: u32) -> u32 => u32_bit_or(a, b)
}

impl BitOr[u64, u64, u64] {
    @inline
    fn |(a: u64, b: u64) -> u64 => u64_bit_or(a, b)
}

/// Bitwise XOR (exclusive OR) operator (`^`).
///
/// Performs a bitwise XOR on each pair of corresponding bits. A result
/// bit is `1` if the input bits differ.
///
/// # Type Parameters
///
/// - `'a` — Left operand type.
/// - `'b` — Right operand type.
/// - `'c` — Result type.
trait BitXor['a, 'b, 'c] {
    /// Returns the bitwise XOR of `a` and `b`.
    fn ^(a: 'a, b: 'b) -> 'c
}

impl BitXor[int, int, int] {
    @inline
    fn ^(a: int, b: int) -> int => int_bit_xor(a, b)
}

impl BitXor[i8, i8, i8] {
    @inline
    fn ^(a: i8, b: i8) -> i8 => i8_bit_xor(a, b)
}

impl BitXor[i16, i16, i16] {
    @inline
    fn ^(a: i16, b: i16) -> i16 => i16_bit_xor(a, b)
}

impl BitXor[i32, i32, i32] {
    @inline
    fn ^(a: i32, b: i32) -> i32 => i32_bit_xor(a, b)
}

impl BitXor[i64, i64, i64] {
    @inline
    fn ^(a: i64, b: i64) -> i64 => i64_bit_xor(a, b)
}

impl BitXor[uint, uint, uint] {
    @inline
    fn ^(a: uint, b: uint) -> uint => uint_bit_xor(a, b)
}

impl BitXor[u8, u8, u8] {
    @inline
    fn ^(a: u8, b: u8) -> u8 => u8_bit_xor(a, b)
}

impl BitXor[u16, u16, u16] {
    @inline
    fn ^(a: u16, b: u16) -> u16 => u16_bit_xor(a, b)
}

impl BitXor[u32, u32, u32] {
    @inline
    fn ^(a: u32, b: u32) -> u32 => u32_bit_xor(a, b)
}

impl BitXor[u64, u64, u64] {
    @inline
    fn ^(a: u64, b: u64) -> u64 => u64_bit_xor(a, b)
}

// ---------------------------------------------------------------------------
// Comparison operators
// ---------------------------------------------------------------------------

/// Equality operator (`==`).
///
/// # Type Parameters
///
/// - `'a` — Left operand type.
/// - `'b` — Right operand type.
///
/// Implemented for all integer types, `bool`, `()` (unit), and nilable
/// types (`'a?`). The nilable implementation compares structurally:
/// `nil == nil` is `true`, `some(x) == some(y)` delegates to `x == y`,
/// and mixed `some`/`nil` comparisons are `false`.
///
/// # Examples
///
/// ```ray
/// if x == 0 {
///     print("zero")
/// }
/// ```
trait Eq['a, 'b] {
    /// Returns `true` if `a` and `b` are equal.
    fn ==(a: 'a, b: 'b) -> bool
}

impl Eq[int, int] {
    @inline
    fn ==(a: int, b: int) -> bool => int_eq(a, b)
}

impl Eq[i8, i8] {
    @inline
    fn ==(a: i8, b: i8) -> bool => i8_eq(a, b)
}

impl Eq[i16, i16] {
    @inline
    fn ==(a: i16, b: i16) -> bool => i16_eq(a, b)
}

impl Eq[i32, i32] {
    @inline
    fn ==(a: i32, b: i32) -> bool => i32_eq(a, b)
}

impl Eq[i64, i64] {
    @inline
    fn ==(a: i64, b: i64) -> bool => i64_eq(a, b)
}

impl Eq[uint, uint] {
    @inline
    fn ==(a: uint, b: uint) -> bool => uint_eq(a, b)
}

impl Eq[u8, u8] {
    @inline
    fn ==(a: u8, b: u8) -> bool => u8_eq(a, b)
}

impl Eq[u16, u16] {
    @inline
    fn ==(a: u16, b: u16) -> bool => u16_eq(a, b)
}

impl Eq[u32, u32] {
    @inline
    fn ==(a: u32, b: u32) -> bool => u32_eq(a, b)
}

impl Eq[u64, u64] {
    @inline
    fn ==(a: u64, b: u64) -> bool => u64_eq(a, b)
}

/// Unit values are always equal.
impl Eq[(), ()] {
    @inline
    fn ==(a: (), b: ()) -> bool => true
}

impl Eq[bool, bool] {
    @inline
    fn ==(a: bool, b: bool) -> bool => bool_eq(a, b)
}

/// Structural equality for nilable types.
///
/// - `nil == nil` is `true`
/// - `some(x) == some(y)` delegates to `x == y`
/// - `some(_) == nil` and `nil == some(_)` are `false`
impl Eq['a?, 'a?] where Eq['a, 'a] {
    @inline
    fn ==(a: 'a?, b: 'a?) -> bool {
        if some(av) = a {
            if some(bv) = b {
                av == bv
            } else {
                false
            }
        } else {
            if some(_) = b {
                false
            } else {
                true
            }
        }
    }
}

/// Inequality operator (`!=`).
///
/// # Type Parameters
///
/// - `'a` — Left operand type.
/// - `'b` — Right operand type.
///
/// The nilable implementation is defined as the negation of `Eq`.
trait Neq['a, 'b] {
    /// Returns `true` if `a` and `b` are not equal.
    fn !=(a: 'a, b: 'b) -> bool
}

impl Neq[int, int] {
    @inline
    fn !=(a: int, b: int) -> bool => int_neq(a, b)
}

impl Neq[i8, i8] {
    @inline
    fn !=(a: i8, b: i8) -> bool => i8_neq(a, b)
}

impl Neq[i16, i16] {
    @inline
    fn !=(a: i16, b: i16) -> bool => i16_neq(a, b)
}

impl Neq[i32, i32] {
    @inline
    fn !=(a: i32, b: i32) -> bool => i32_neq(a, b)
}

impl Neq[i64, i64] {
    @inline
    fn !=(a: i64, b: i64) -> bool => i64_neq(a, b)
}

impl Neq[uint, uint] {
    @inline
    fn !=(a: uint, b: uint) -> bool => uint_neq(a, b)
}

impl Neq[u8, u8] {
    @inline
    fn !=(a: u8, b: u8) -> bool => u8_neq(a, b)
}

impl Neq[u16, u16] {
    @inline
    fn !=(a: u16, b: u16) -> bool => u16_neq(a, b)
}

impl Neq[u32, u32] {
    @inline
    fn !=(a: u32, b: u32) -> bool => u32_neq(a, b)
}

impl Neq[u64, u64] {
    @inline
    fn !=(a: u64, b: u64) -> bool => u64_neq(a, b)
}

/// Unit values are never unequal.
impl Neq[(), ()] {
    @inline
    fn !=(a: (), b: ()) -> bool => false
}

impl Neq[bool, bool] {
    @inline
    fn !=(a: bool, b: bool) -> bool => bool_neq(a, b)
}

/// Inequality for nilable types, defined as the negation of `==`.
impl Neq['a?, 'a?] where Eq['a, 'a] {
    @inline
    fn !=(a: 'a?, b: 'a?) -> bool => !(a == b)
}

/// Greater-than comparison operator (`>`).
///
/// # Type Parameters
///
/// - `'a` — Left operand type.
/// - `'b` — Right operand type.
trait Gt['a, 'b] {
    /// Returns `true` if `a` is strictly greater than `b`.
    fn >(a: 'a, b: 'b) -> bool
}

impl Gt[int, int] {
    @inline
    fn >(a: int, b: int) -> bool => int_gt(a, b)
}

impl Gt[i8, i8] {
    @inline
    fn >(a: i8, b: i8) -> bool => i8_gt(a, b)
}

impl Gt[i16, i16] {
    @inline
    fn >(a: i16, b: i16) -> bool => i16_gt(a, b)
}

impl Gt[i32, i32] {
    @inline
    fn >(a: i32, b: i32) -> bool => i32_gt(a, b)
}

impl Gt[i64, i64] {
    @inline
    fn >(a: i64, b: i64) -> bool => i64_gt(a, b)
}

impl Gt[uint, uint] {
    @inline
    fn >(a: uint, b: uint) -> bool => uint_gt(a, b)
}

impl Gt[u8, u8] {
    @inline
    fn >(a: u8, b: u8) -> bool => u8_gt(a, b)
}

impl Gt[u16, u16] {
    @inline
    fn >(a: u16, b: u16) -> bool => u16_gt(a, b)
}

impl Gt[u32, u32] {
    @inline
    fn >(a: u32, b: u32) -> bool => u32_gt(a, b)
}

impl Gt[u64, u64] {
    @inline
    fn >(a: u64, b: u64) -> bool => u64_gt(a, b)
}

/// Less-than comparison operator (`<`).
///
/// # Type Parameters
///
/// - `'a` — Left operand type.
/// - `'b` — Right operand type.
trait Lt['a, 'b] {
    /// Returns `true` if `a` is strictly less than `b`.
    fn <(a: 'a, b: 'b) -> bool
}

impl Lt[int, int] {
    @inline
    fn <(a: int, b: int) -> bool => int_lt(a, b)
}

impl Lt[i8, i8] {
    @inline
    fn <(a: i8, b: i8) -> bool => i8_lt(a, b)
}

impl Lt[i16, i16] {
    @inline
    fn <(a: i16, b: i16) -> bool => i16_lt(a, b)
}

impl Lt[i32, i32] {
    @inline
    fn <(a: i32, b: i32) -> bool => i32_lt(a, b)
}

impl Lt[i64, i64] {
    @inline
    fn <(a: i64, b: i64) -> bool => i64_lt(a, b)
}

impl Lt[uint, uint] {
    @inline
    fn <(a: uint, b: uint) -> bool => uint_lt(a, b)
}

impl Lt[u8, u8] {
    @inline
    fn <(a: u8, b: u8) -> bool => u8_lt(a, b)
}

impl Lt[u16, u16] {
    @inline
    fn <(a: u16, b: u16) -> bool => u16_lt(a, b)
}

impl Lt[u32, u32] {
    @inline
    fn <(a: u32, b: u32) -> bool => u32_lt(a, b)
}

impl Lt[u64, u64] {
    @inline
    fn <(a: u64, b: u64) -> bool => u64_lt(a, b)
}

/// Greater-than-or-equal comparison operator (`>=`).
///
/// # Type Parameters
///
/// - `'a` — Left operand type.
/// - `'b` — Right operand type.
trait GtEq['a, 'b] {
    /// Returns `true` if `a` is greater than or equal to `b`.
    fn >=(a: 'a, b: 'b) -> bool
}

impl GtEq[int, int] {
    @inline
    fn >=(a: int, b: int) -> bool => int_gteq(a, b)
}

impl GtEq[i8, i8] {
    @inline
    fn >=(a: i8, b: i8) -> bool => i8_gteq(a, b)
}

impl GtEq[i16, i16] {
    @inline
    fn >=(a: i16, b: i16) -> bool => i16_gteq(a, b)
}

impl GtEq[i32, i32] {
    @inline
    fn >=(a: i32, b: i32) -> bool => i32_gteq(a, b)
}

impl GtEq[i64, i64] {
    @inline
    fn >=(a: i64, b: i64) -> bool => i64_gteq(a, b)
}

impl GtEq[uint, uint] {
    @inline
    fn >=(a: uint, b: uint) -> bool => uint_gteq(a, b)
}

impl GtEq[u8, u8] {
    @inline
    fn >=(a: u8, b: u8) -> bool => u8_gteq(a, b)
}

impl GtEq[u16, u16] {
    @inline
    fn >=(a: u16, b: u16) -> bool => u16_gteq(a, b)
}

impl GtEq[u32, u32] {
    @inline
    fn >=(a: u32, b: u32) -> bool => u32_gteq(a, b)
}

impl GtEq[u64, u64] {
    @inline
    fn >=(a: u64, b: u64) -> bool => u64_gteq(a, b)
}

/// Less-than-or-equal comparison operator (`<=`).
///
/// # Type Parameters
///
/// - `'a` — Left operand type.
/// - `'b` — Right operand type.
trait LtEq['a, 'b] {
    /// Returns `true` if `a` is less than or equal to `b`.
    fn <=(a: 'a, b: 'b) -> bool
}

impl LtEq[int, int] {
    @inline
    fn <=(a: int, b: int) -> bool => int_lteq(a, b)
}

impl LtEq[i8, i8] {
    @inline
    fn <=(a: i8, b: i8) -> bool => i8_lteq(a, b)
}

impl LtEq[i16, i16] {
    @inline
    fn <=(a: i16, b: i16) -> bool => i16_lteq(a, b)
}

impl LtEq[i32, i32] {
    @inline
    fn <=(a: i32, b: i32) -> bool => i32_lteq(a, b)
}

impl LtEq[i64, i64] {
    @inline
    fn <=(a: i64, b: i64) -> bool => i64_lteq(a, b)
}

impl LtEq[uint, uint] {
    @inline
    fn <=(a: uint, b: uint) -> bool => uint_lteq(a, b)
}

impl LtEq[u8, u8] {
    @inline
    fn <=(a: u8, b: u8) -> bool => u8_lteq(a, b)
}

impl LtEq[u16, u16] {
    @inline
    fn <=(a: u16, b: u16) -> bool => u16_lteq(a, b)
}

impl LtEq[u32, u32] {
    @inline
    fn <=(a: u32, b: u32) -> bool => u32_lteq(a, b)
}

impl LtEq[u64, u64] {
    @inline
    fn <=(a: u64, b: u64) -> bool => u64_lteq(a, b)
}
