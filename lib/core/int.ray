//! Integer types and their trait implementations.
//!
//! Ray provides both signed and unsigned integer types in various widths:
//!
//! | Signed   | Unsigned | Width     |
//! |----------|----------|-----------|
//! | `int`    | `uint`   | native    |
//! | `i8`     | `u8`     | 8-bit     |
//! | `i16`    | `u16`    | 16-bit    |
//! | `i32`    | `u32`    | 32-bit    |
//! | `i64`    | `u64`    | 64-bit    |
//!
//! All integer types implement `Int`. Signed types additionally implement
//! `SignedInt`, and unsigned types implement `UnsignedInt`. These marker
//! traits are used as constraints for generic integer algorithms (e.g.
//! `Hash` and `ToStr` implementations).

/// Marker trait for all integer types.
///
/// The default type is `int` (the native-width signed integer).
trait Int['a] {
    default (int)
}

/// Marker trait for signed integer types (`int`, `i8`, `i16`, `i32`, `i64`).
trait SignedInt['a] {}
/// Marker trait for unsigned integer types (`uint`, `u8`, `u16`, `u32`, `u64`).
trait UnsignedInt['a] {}

impl Int[int] {}
impl SignedInt[int] {}
impl Int[i8] {}
impl SignedInt[i8] {}
impl Int[i16] {}
impl SignedInt[i16] {}
impl Int[i32] {}
impl SignedInt[i32] {}
impl Int[i64] {}
impl SignedInt[i64] {}

impl Int[uint] {}
impl UnsignedInt[uint] {}
impl Int[u8] {}
impl UnsignedInt[u8] {}
impl Int[u16] {}
impl UnsignedInt[u16] {}
impl Int[u32] {}
impl UnsignedInt[u32] {}
impl Int[u64] {}
impl UnsignedInt[u64] {}

/// FNV-1a hashing for all integer types.
impl Hash['a] where Int['a] {
    fn hash(self: 'a) -> u64 {
        mut packed, len = int_hash_bytes(self)

        // FNV-1a (64-bit)
        mut h: u64 = 14695981039346656037u64
        mut i: uint = 0
        while i < len {
            byte = packed % 256
            h = h ^ byte
            h = h * 1099511628211
            packed = packed / 256
            i += 1
        }

        h
    }
}

/// Converts an unsigned integer to its decimal string representation.
impl ToStr['a] where UnsignedInt['a], Int['a], Div['a, 'a, 'a], Mod['a, 'a, 'a], Eq['a, 'a] {
    fn to_str(self: 'a) -> string {
        mut len = 1
        mut i = self
        while true {
            i /= 10
            if i == 0 {
                break
            }
            len += 1
        }

        raw_ptr = malloc(len)
        char_len = len
        i = self
        mut ptr = raw_ptr + (len - 1)
        while true {
            *ptr = ('0' as u8) + ((i % 10) as u8)
            ptr = ptr - 1
            i /= 10
            if i == 0 {
                break
            }
        }

        string { raw_ptr, len, char_len }
    }
}

/// Converts a signed integer to its decimal string representation.
///
/// Negative values are prefixed with `-`.
impl ToStr['a] where SignedInt['a], Int['a], Lt['a, 'a], Neg['a, 'a], Div['a, 'a, 'a], Mod['a, 'a, 'a], Eq['a, 'a] {
    fn to_str(self: 'a) -> string {
        mut len = 1
        mut i = abs(self)
        while true {
            i /= 10
            if i == 0 {
                break
            }
            len += 1
        }

        if self < 0 {
            len += 1
        }

        raw_ptr = malloc(len)
        char_len = len
        i = abs(self)
        mut ptr = raw_ptr + (len - 1)
        while true {
            *ptr = ('0' as u8) + ((i % 10) as u8)
            ptr = ptr - 1
            i /= 10
            if i == 0 {
                break
            }
        }

        if self < 0 {
            *ptr = '-' as u8
        }

        string { raw_ptr, len, char_len }
    }
}
